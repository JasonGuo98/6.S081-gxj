# FileSystem_lab

本次练习会为xv6的文件系统添加大文件和符号链接的功能。

在写代码之前，应该先阅读第八章的文件系统相关内容，并且理解相关的代码。

```shell
  $ git fetch
  $ git checkout fs
  $ make clean
```

## Chapter 8 File system

文件系统的初衷是组织并存储数据。典型的文件系统支持在用户和应用之间共享数据，以及持久化，使得数据在重启后还能获取。

xv6的文件系统提供类Unix的文件、目录，以及路径名。数据被存储在虚拟磁盘上以进行持久化。文件系统需要解决以下的一些挑战：

* 文件系统需要使用在磁盘上的数据结构来表示目录树以及文件，记录存储每个文件内容的块的身份，记录那些磁盘区域是空闲的。
* 文件系统需要支持*crash recovery*。也就是说，在崩溃发生后（比如掉电），文件系统需要在重启后仍然能正确工作。这里的风险是，崩溃可能打断正在执行的一连串更新，使得在磁盘上的数据结构不一致（inconsistent）（比如，一个块被使用，但是被标记为空闲）。
* 不同的进程可能同时使用文件系统，因此文件系统代码必须协调以保持不变量。
* 访问磁盘比访问内存会慢数个数量级，因此文件系统必须在内存中维护缓存用于热数据块

接下来的章节介绍了xv6如何解决以上的问题。

### 8.1 Overview

### Buffer cache layer

### Code: Buffer cache

这里的主要的函数就是`bget`，`brelse`，`bread`，`bwrite`。通过`bget`获得在内存的`struct buf`，读取时，能够直接将内存进行；写入时则进行持久化。比如需要获取同样的数据块，如果已经在内存中则直接能缓存命中。

### Logging layer

在文件系统中最有意思的一个问题是如何崩溃恢复。这问题的出现是因为文件系统的更新会涉及到在磁盘上的多个读取，如果在更新未完成的时候发生崩溃，则可能让磁盘上的文件系统处在不一致的状态。例如，假设在文件截断（truncation，将文件的长度设置为0，并释放其数据块）期间发生崩溃。机遇与磁盘写入的顺序，崩溃可能使得问价系统的inode指向一个被标记为空闲的内容数据块，或者在磁盘上剩下被分配了的但是没有被指向的数据块。

后者是相对良性的，但是一个inode指向一个被释放的块，重启后可能导致严重的问题。在重启后，内核可能分配这个数据块给到另一个文件，使得有两个文件指向相同的数据块。如果xv6支持多用户，则这可能产生安全问题，因为老的文件的持有者的可能能读取到另一个用户的新文件的写入。

xv6通过简单结构的`logging`来解决这以文件系统操作期间崩溃的问题。一个xv6系统调用不会直接写在磁盘上的文件系统数据结构。相反的，系统将对所有的希望对磁盘的写入的描述，存储在磁盘上的log中。一旦系统调用将所有的写入存储在日志中，其写入一个特殊的`commit`记录到磁盘上，以表示这个日志包含一个完整的操作。在这个时间点，该系统调用在复制写入数据到磁盘的文件系统数据结构中。在这个写入完成后，系统调用释放在磁盘上的日志。

如果系统崩溃并重启，文件系统代码在任何其他进程启动前，按照如下方式恢复数据：如果日志被标记为存储有一个完整的操作，则恢复代码复制该写入到磁盘上的文件系统中的正确位置上。如果日志没有被标记为包含完整的操作，恢复代码忽略这个log。恢复代码结束后会释放log。

为什么日志解决了文件系统操作期间崩溃的恢复问题？如果操作在commit之前发生，则日志不会被标记完成，恢复代码会忽略它，磁盘状态为该操作没有发生前的状态。如果崩溃发生在操作被commit之后，则恢复代码会重放所有的操作写，以操作完全没有发生的状态从头到尾执行一次。这种被标记完成的操作相对崩溃来说，是原子的：恢复后，要么所有操作，要么不完成。

### 8.5 Log design

日志存储在一个已知的固定区域，由超级块决定。其包含一个header block，以及随后的连续的更新数据块（“logged blocks”）。header block包含一个sector number数组，用于每个日志中的数据块，日志数据块个数。在header block的计数器要么是0，说明现在没有事务在日志中；要么是非0，说明有事务在日志中，并且日志块个数是`count`个。xv6通过写入header block来完成事务的提交，在将日志中的数据块拷贝到文件系统后，将计数器置零。于是在日志commit之前的崩溃会使得计数器为0，在commit之后的崩溃会使得计数器为非0。

每个系统调用说明写入数据的连续起止地址，并且必须相对崩溃原子的写入。为了让不同的进程能够并发的执行文件系统操作，日志系统能将多个写入累积成一个事务进行提交。于是单个提交可能涉及到多个系统调用的完成。为了避免将系统调用在事务之间切分，日志系统仅在没有文件系统系统调用未完成时commit。